Приложение за управление на моите лични финанси:

За да реализираме потребителски интерфейс и логика за взаимодействие, ще използваме библиотеки като input() за въвеждане на данни и print() за извеждане на  информация на потребителя. Приложението управлява и следи за моето финансово състояние, включващо: разходи, приходи, техният източник и тип, дата на 
движение, сума. 
Възможност за проверка на моментният ми бюджет, с цел да добавям, преглеждам, редактирам и изтривам финансови записи и трансакции.  

Структура на приложението: 
# main.py
Този скрипт импортира класа FinanceManager от модула finance_manager и създава обект от този клас, след което извиква метода run() върху него.

# finance_manager.py
Позволява на потребителя да въведе разходи и приходи, да преглежда всички записи и да вижда обобщени статистики. 
- Съхранение на данни и статистики: използваме отделни класове за съхранение на данни (класът FinanceDatabase) и за изчисляване на статистики (класът FinanceStatistics).
- Валидация на входни данни: приемаме входни данни от потребителя с помощта на input(). 

# finance_database.py
За създаване на таблиците в базата данни с SQLite, трябва да изпълним SQL заявка, която дефинира структурата на всяка таблица. Във функцията create_tables в FinanceDatabase. Този код създава две таблиците - expenses и incomes. Те съдържат колони, определящи основните характеристики на разходите и приходите. С CREATE TABLE IF NOT EXISTS се гарантира, че таблиците ще бъдат създадени само ако все още не съществуват.
За да добавим запис към базата данни, трябва да използваме SQL INSERT заявка. Във функцията add_record в FinanceDatabase.
Този код проверява типа на записа (дали е разход или приход) и в зависимост от това изпълнява съответната SQL INSERT заявка. След това данните се добавят към съответната таблица в базата данни.
За извлечане на записи от базата данни съобразно определени филтри и сортиране, ще използваме SQL SELECT заявка. Във функцията get_records в FinanceDatabase.
Този код създава SQL заявка, която съчетава записите от таблиците за разходи и приходи. След това прилага филтриране и сортиране върху тези записи 
в зависимост от предоставените параметри.
Използваме съединяване на двете таблиците с UNION ALL, което предполага, че структурата на таблиците е еднаква. Ако има разлики в структурата на таблиците, 
ще трябва да се направят съответните промени в заявката.

# finance_statistics.py
В методите get_overall_budget и get_average_expense използваме проверка дали записът е разход или приход чрез isinstance.
Изчисление на средната стойност на разходите е в метода get_average_expense има опция за задаване на период.
Обработка на случая с нулеви разходи е в метода get_rundown и проверяваме дали средният разход е равен на 0.

# finance_record.py
Класовете във файлът finance_record.py, използваме наследяване, за да споделим общата функционалност между разходи и приходи, което е добра практика 
за повторно използване на кода.
Тук се добавя валидация на сумата, датата и описанието при създаване на разход или приход. Ако въведените данни не съответстват на изискванията,
ще се вдигне изключение с подходящо съобщение за грешка.

# test_finance_manager.py
Използваме unittest за създаване на тестове, което е стандартен начин за тестване на Python код.
Използваме @patch декоратора за да мокваме външни зависимости, което е добра практика за изолиране на тестовете от външния свят. 

# finance.db
Този файл съдържа базата данни в SQLite на приложението.
